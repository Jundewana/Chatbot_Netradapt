"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("underscore");
var EvalType;
(function (EvalType) {
    EvalType[EvalType["ET_COST"] = 0] = "ET_COST";
    EvalType[EvalType["ET_FITNESS"] = 1] = "ET_FITNESS";
})(EvalType = exports.EvalType || (exports.EvalType = {}));
/** Generate a new random population
 *  Used for initialization
 */
exports.randomPopulation = function (config, len, popSize) {
    return {
        elements: _.times(popSize, function () { return exports.randomGene(config, len); }),
        generation: 0
    };
};
/** Generate a random gene sequence */
exports.randomGene = function (config, len) {
    return {
        code: _.sample(config.dnaCodes, len),
        score: undefined,
        fitness: undefined,
        cost: undefined
    };
};
/** Calculate normalized (0-1) score from cost range of population */
exports.score = function (config, population) {
    if (config.evalType === EvalType.ET_COST) {
        var costed = _.map(population.elements, function (e) {
            e.cost = config.evalFn(e.code);
            return e;
        });
        var minCostGene_1 = _.min(costed, function (e) { return e.cost; });
        var maxCostGene = _.max(costed, function (e) { return e.cost; });
        var range_1 = (maxCostGene.cost - minCostGene_1.cost) || 1; // Prevent divide by zero
        // when all elements are the same
        var scored = _.map(costed, function (e) {
            e.score = 1.0 - ((e.cost - minCostGene_1.cost) / range_1);
            return e;
        });
        var newPopulation = _.clone(population); // TODO: better cloning?
        newPopulation.elements = scored;
        return newPopulation;
    }
    else if (config.evalType === EvalType.ET_FITNESS) {
        var scored = _.map(population.elements, function (e) {
            e.fitness = config.evalFn(e.code);
            e.score = e.fitness;
            return e;
        });
        var newPopulation = _.clone(population); // TODO: better cloning?
        newPopulation.elements = scored;
        return newPopulation;
    }
    fail("Unexpected evalType");
};
/** Pick a random parent, based on giving higher chance
 *  to elements having higher score
 */
var pickParent = function (population) {
    // NOTE: population must be scored already
    // TODO: How to assert?
    var minScoreGene = _.min(population.elements, function (e) { return e.score; });
    var maxScoreGene = _.max(population.elements, function (e) { return e.score; });
    var potentialParent = _.sample(population.elements);
    if (minScoreGene.score === maxScoreGene.score) {
        return potentialParent;
    }
    // Accept-reject mechanism
    // https://www.wikiwand.com/en/Rejection_sampling
    while (true) {
        if (potentialParent.score > Math.random()) {
            return potentialParent;
        }
        potentialParent = _.sample(population.elements);
    }
    fail("Unexpected code flow");
};
/** Mutate, or not */
var maybeMutate = function (config, gene, chance) {
    if (Math.random() > chance)
        return gene;
    var index = _.random(gene.code.length - 1);
    var res = _.clone(gene);
    res.code[index] = config.mutate(res.code[index], config.dnaCodes);
    return res;
};
/** Mate two genes */
var mateWrapper = function (config, gene1, gene2) {
    var res = _.clone(gene1);
    res.code = config.mate(gene1.code, gene2.code);
    return res;
};
/** Evolve population to its next generation */
exports.evolve = function (config, population, mutationRate) {
    var children = [];
    // Next generation's population count is same as current
    while (children.length < population.elements.length) {
        children.push(_.compose(function (gene) {
            return gene;
        }, function (gene) {
            return maybeMutate(config, gene, mutationRate);
        }, function () {
            return mateWrapper(config, pickParent(population), pickParent(population));
        })());
    }
    var res = _.clone(population); // TODO: better cloning?
    res.generation = population.generation + 1;
    res.elements = children;
    return res;
};
var fail = function (message) { throw new Error(message); };
